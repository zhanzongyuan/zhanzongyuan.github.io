{"summary":"<p>P老师：阅读、学习、模仿包的源代码是提高代码能力的最好方式（前提这是一个好的包）</p>\n<a id=\"more\"></a>\n<p>”Golang中的http包提供http客户端和服务器的实现“，godoc第一句便这样写道。</p>\n<blockquote>\n<p><a href=\"https://godoc.org/net/http\" target=\"_blank\" rel=\"noopener\">Package http provides HTTP client and server implementations.</a></p>\n</blockquote>\n<p>包的学习在我看来有两个阶段：学习使用 —&gt; 学习实现。</p>\n<h2 id=\"http包实践\"><a href=\"#http包实践\" class=\"headerlink\" title=\"http包实践\"></a>http包实践</h2><p>​    <strong>学习使用</strong>最简单的开始就是仔细阅读该包godoc的第一句话，如http包一句话简单明了的介绍http包的作用，为开发者们示范了优秀文档的特点：简单明了！概括了http包所有的功能，即Client&amp;Server。</p>\n<p>​    简单了解一个包的作用后再仔细看文档下面的例子。好的文档一般会在开头部分写好常用的接口Examples，如http包：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Example: Client</span></span><br><span class=\"line\">resp, err := http.Get(<span class=\"string\">\"http://example.com/\"</span>)</span><br><span class=\"line\">...</span><br><span class=\"line\">resp, err := http.Post(<span class=\"string\">\"http://example.com/upload\"</span>, <span class=\"string\">\"image/jpeg\"</span>, &amp;buf)</span><br><span class=\"line\">...</span><br><span class=\"line\">resp, err := http.PostForm(<span class=\"string\">\"http://example.com/form\"</span>,</span><br><span class=\"line\">\turl.Values&#123;<span class=\"string\">\"key\"</span>: &#123;<span class=\"string\">\"Value\"</span>&#125;, <span class=\"string\">\"id\"</span>: &#123;<span class=\"string\">\"123\"</span>&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Example: Server</span></span><br><span class=\"line\">http.Handle(<span class=\"string\">\"/foo\"</span>, fooHandler)</span><br><span class=\"line\"></span><br><span class=\"line\">http.HandleFunc(<span class=\"string\">\"/bar\"</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Fprintf(w, <span class=\"string\">\"Hello, %q\"</span>, html.EscapeString(r.URL.Path))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">log.Fatal(http.ListenAndServe(<span class=\"string\">\":8080\"</span>, <span class=\"literal\">nil</span>))</span><br></pre></td></tr></table></figure>\n<p>结合你当前对http的理解，很快就会把http包的API分为两类：Client&amp;Server，你也会意识到http包的接口是多么的简单好用。</p>\n<p>但是这个阶段你只是对包有个API层面的理解，如果你没有朝着系统工程师发展的打算，你或许就止步于仅仅使用这个包，将其视为黑盒。</p>\n<h2 id=\"http实现\"><a href=\"#http实现\" class=\"headerlink\" title=\"http实现\"></a>http实现</h2><p>​    以往我阅读一个包的时候我都是直接打开<a href=\"https://sourcegraph.com对应的代码源，去浏览整个包的各个部分。这种方式是低效的，而且当代码量大的时候更是不切实际的。后来了解到vim和vscode对应的go插件中都有个“go\" target=\"_blank\" rel=\"noopener\">https://sourcegraph.com对应的代码源，去浏览整个包的各个部分。这种方式是低效的，而且当代码量大的时候更是不切实际的。后来了解到vim和vscode对应的go插件中都有个“go</a> to definition“的功能，甚至还有一个”list all references”的功能（慎用，一般很慢）。虽然这些功能都在sourcegraph上有，但是在自己打出来的代码上去追溯实现感觉更有针对性。</p>\n<h3 id=\"Client\"><a href=\"#Client\" class=\"headerlink\" title=\"Client\"></a>Client</h3><p>以文档中Client例子进行追溯：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resp, err := http.Get(<span class=\"string\">\"http://example.com/\"</span>)</span><br><span class=\"line\">-&gt; <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Get</span><span class=\"params\">(url <span class=\"keyword\">string</span>)</span> <span class=\"params\">(resp *Response, err error)</span></span></span><br><span class=\"line\"><span class=\"function\">-&gt; <span class=\"title\">func</span> <span class=\"params\">(c *Client)</span> <span class=\"title\">Get</span><span class=\"params\">(url <span class=\"keyword\">string</span>)</span> <span class=\"params\">(resp *Response, err error)</span></span></span><br><span class=\"line\"><span class=\"function\">-&gt; <span class=\"title\">func</span> <span class=\"params\">(c *Client)</span> <span class=\"title\">Do</span><span class=\"params\">(req *Request)</span> <span class=\"params\">(*Response, error)</span></span></span><br></pre></td></tr></table></figure>\n<p>​    追溯源码要学会先去看程序头的注释，看完注释即能了解一个函数的大致作用。接着阅读主体的时候不要陷入咬文嚼字，要学会过滤性的阅读，比如代码中的各种错误处理分支可以暂时忽略，先看程序的主支。一般来说，包对外export的API部分都可以追溯进去看一下。</p>\n<p>​    这个追溯的过程中，你应该去思考的是这个包是怎么分层的（包的解析就像拨开一层层的洋葱，套了一层层的wrapper），你有理由去思考为什么这个地方要这样去wrap，为什么要把这个API开放出来。以http.Get为例子，http.Get、http.Post、http.PostForm都是在wrap了http.Do，其实可以只开放http.Do的接口，让我们外部实现这些方法，开放着三个API是因为符合用语习惯（方便使用，但是使用不够自由），而还继续export了http.Do方法，为了使用者更加自由的使用这个方法。</p>\n<p>​    接着思考这过程中涉及到的实体之间的关系，实体之间交互是怎么实现的。</p>\n<p><img src=\"go之http包解析/image-20181117204818076.png\" alt=\"image-20181117204818076\"></p>\n<h3 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.HandleFunc(<span class=\"string\">\"/\"</span>, sayHelloWorld)</span><br><span class=\"line\">-&gt; <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span></span><br><span class=\"line\"><span class=\"function\">-&gt; <span class=\"title\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span></span><br><span class=\"line\"><span class=\"function\">-&gt; <span class=\"title\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handle</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler Handler)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\">http.ListenAndServe(\":8080\", nil)</span><br><span class=\"line\">-&gt; <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, handler Handler)</span></span></span><br><span class=\"line\"><span class=\"function\">-&gt; <span class=\"title\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">-&gt; <span class=\"title\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">Serve</span><span class=\"params\">(l net.Listener)</span></span></span><br></pre></td></tr></table></figure>\n<p>​    同样追溯Server的示例，结合Client的分析可以总结出一个特点，就是前面几层的wrapper都是为了对外提供多样化的API而构建的，并不是处理服务的核心。下面是对Server结构做了一个简单的解析</p>\n<p><img src=\"go之http包解析/image-20181117205625203.png\" alt=\"image-20181117205625203\"></p>\n<p>​    在追溯的过程中发现接口时，应该停下来思考为什么这个地方使用的是接口，而不是直接定义好的实体，是为了更好的拓展吗。如这里的Handler类型就是一个接口类型，方便使用者自定义接口类似设计模式中<strong>模板方法（Template method）</strong>。</p>\n<p>​    ServeMux is an HTTP request multiplexer(<a href=\"https://en.wikipedia.org/wiki/Multiplexer\" target=\"_blank\" rel=\"noopener\">MUX</a>)，即为一个多路复用选择器，也叫路由器，受请求路径的控制选择不同的Handler处理请求。</p>\n<p>​    Server的实现比Client复杂许多，不止设计到Resquest&amp;Response，还涉及到Handler、net.Listener等接口和ServeMux等其他实体（ServeMux也实现了Handler的接口，所以可以成为Server上的handler对象），再深入挖掘就会看到很多奇奇怪怪的陌生类型和函数，过滤错误处理等部分可以省去很大麻烦。</p>\n"}