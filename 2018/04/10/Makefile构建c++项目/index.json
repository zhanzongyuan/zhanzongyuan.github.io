{"summary":"<blockquote>\n<p>做计算机视觉作业时，要用到CImg库，发现居然Xcode不能链接到CImg头文件里面引用的X11链接库，于是在网上找了各种方法。最终重新捡起Makefile搭建c++项目。</p>\n</blockquote>\n<h2 id=\"1-g\"><a href=\"#1-g\" class=\"headerlink\" title=\"1. g++\"></a>1. g++</h2><p>说到g++，这里我们先解释gcc：</p>\n<h3 id=\"1-1-gcc是啥\"><a href=\"#1-1-gcc是啥\" class=\"headerlink\" title=\"1.1 gcc是啥\"></a>1.1 gcc是啥</h3><blockquote>\n<p>gcc : GNU CC(简称gcc)是GNU项目中符合ANSI C标准的编译系统，能够编译用C、C++、Object<br>C、Jave等多种语言编写的程序。gcc又可以作为交叉编译工具，它能够在当前CPU平台上为多种不同体系结构的硬件平台开发软件，非常适合在嵌入式领域的开发编译，如常用的arm-linux-gcc交叉编译工具</p>\n<p>参考：<a href=\"https://blog.csdn.net/zhaoyue007101/article/details/7699554\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhaoyue007101/article/details/7699554</a></p>\n<p>简而言之gcc是个编译器</p>\n</blockquote>\n<h3 id=\"1-2-gcc和g\"><a href=\"#1-2-gcc和g\" class=\"headerlink\" title=\"1.2 gcc和g++\"></a>1.2 gcc和g++</h3><p>引用一段知乎的回答：</p>\n<blockquote>\n<p>gcc 最开始的时候是 GNU C Compiler,  如你所知，就是一个c编译器。但是后来因为这个项目里边集成了更多其他不同语言的编译器，GCC就代表 the GNU Compiler Collection，所以表示一堆编译器的合集。 g++则是GCC的c++编译器。作者：李锋链接：<a href=\"https://www.zhihu.com/question/20940822/answer/16667772来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/20940822/answer/16667772来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>\n</blockquote>\n<h3 id=\"1-3-gcc-参数\"><a href=\"#1-3-gcc-参数\" class=\"headerlink\" title=\"1.3 gcc 参数\"></a>1.3 gcc 参数</h3><blockquote>\n<p>对于c++工程而言，gcc就是调用的g++编译器</p>\n<p>对于普通的c工程，gcc用的不是g++编译器，由于g++编译器也会把c文件当作c++文件编译，只是链接的时候链接库不同罢了</p>\n</blockquote>\n<p>命令格式：<code>gcc [option] [file]</code></p>\n<h4 id=\"1-3-1-详细编译流程\"><a href=\"#1-3-1-详细编译流程\" class=\"headerlink\" title=\"1.3.1 详细编译流程\"></a>1.3.1 详细编译流程</h4><p>1.预处理-Pre-Processing</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc  -E  hello_world.c  -o  hello_world.i    //.i文件</span><br></pre></td></tr></table></figure>\n<p>2.编译-Compiling</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc  -S  hello_world.i  -o   hello_world.s  //.s文件</span><br></pre></td></tr></table></figure>\n<p>3.汇编-Assembling     </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc  -c  hello_world.s  -o  gcc  -c  hello_world.s  -o  hello_world.o     //.o文件</span><br></pre></td></tr></table></figure>\n<p>4.链接-Linking          </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc  hello_world.o  -o  hello_world //bin文件，可执行文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-2-项目惯用流程\"><a href=\"#1-3-2-项目惯用流程\" class=\"headerlink\" title=\"1.3.2 项目惯用流程\"></a>1.3.2 项目惯用流程</h4><ol>\n<li>编译</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -c hello_world.c -c hello_world.o</span><br></pre></td></tr></table></figure>\n<ol>\n<li>链接</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc hello_world.o -c hello_world</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于c++项目是一样命令，只是gcc改成g++</p>\n</blockquote>\n<h4 id=\"1-3-3-参数解释\"><a href=\"#1-3-3-参数解释\" class=\"headerlink\" title=\"1.3.3 参数解释\"></a>1.3.3 参数解释</h4><blockquote>\n<p>大小写有区分</p>\n</blockquote>\n<ul>\n<li>-E参数<ul>\n<li>-E 选项指示编译器仅对输入文件进行预处理。当这个选项被使用时, 预处理器的输出被送到标准输出而不是储</li>\n</ul>\n</li>\n<li>-S参数<ul>\n<li>-S 编译选项告诉 GCC 在为 C 代码产生了汇编语言文件后停止编译。 GCC 产生的汇编语言文件的缺省扩展名</li>\n</ul>\n</li>\n<li>-c参数<ul>\n<li>-c 选项告诉 GCC 仅把源代码编译为目标代码。缺省时 GCC 建立的目标代码文件有一个 .o 的扩展名。</li>\n</ul>\n</li>\n<li>-o参数<ul>\n<li>-o 编译选项来为将产生的可执行文件用指定的文件名。</li>\n</ul>\n</li>\n<li>-O参数<ul>\n<li>-O 选项告诉 GCC 对源代码进行基本优化。这些优化在大多数情况下都会使程序执行的更快。 -O2 选项告诉：<ul>\n<li>GCC 产生尽可能小和尽可能快的代码。 如-O2，-O3，-On（n 常为0—3）；</li>\n<li>-O  主要进行跳转和延迟退栈两种优化；</li>\n<li>-O2 除了完成-O1的优化之外，还进行一些额外的调整工作，如指令调整等。</li>\n<li>-O3 则包括循环展开和其他一些与处理特性相关的优化工作。</li>\n<li>选项将使编译的速度比使用 -O 时慢， 但通常产生的代码执行速度会更快。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>调试选项-g和-pg<ul>\n<li>GCC 支持数种调试和剖析选项，常用到的是 -g 和 -pg 。</li>\n<li>-g 选项告诉 GCC 产生能被 GNU 调试器使用的调试信息以便调试你的程序。GCC 提供了一个很多其他 C 编译器里没有的特性, 在 GCC 里你能使-g 和 -O (产生优化代码)联用。</li>\n<li>-pg 选项告诉 GCC 在编译好的程序里加入额外的代码。运行程序时, 产生 gprof 用的剖析信息以显示你的程序的</li>\n</ul>\n</li>\n<li>-l参数和-L参数（前面是小写的L）<ul>\n<li>-l参数就是用来指定程序要链接的库，-l参数紧接着就是库名，那么库名跟真正的库文件名有什么关系呢？-L指定库文件的所在的目录，结合-L就可以链接第三方库文件。</li>\n<li>pthread例子：<code>-lpthread</code></li>\n<li>CImg的例子：<code>-L./src/lib/X11/lib -lX11</code>，这个表示在<code>#include&lt;X11&gt;</code>的时候用<code>./src/lib/X11/lib</code>里的库文件libX11，一般在链接的时候用</li>\n</ul>\n</li>\n<li>-I（这是大写的i）<ul>\n<li>指定头文件</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>最后留几个问题：</p>\n<p>交叉编译？GNU？</p>\n<p>链接库和引用头文件的区别</p>\n</blockquote>\n<h2 id=\"2-Makefile\"><a href=\"#2-Makefile\" class=\"headerlink\" title=\"2. Makefile\"></a>2. Makefile</h2><p>语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target: [target1] [target2] ....</span><br><span class=\"line\">\tcommand 1</span><br><span class=\"line\">\tcommand 2</span><br></pre></td></tr></table></figure>\n<p>target是指具体某个文件，或者是某个命令的变量名如：run</p>\n<p>这里相当于target0需要target1和target2等依赖，必须先运行target1，target2下的命令才能运行target0</p>\n<p>command是shell命令，这里可以直接<code>g++ -c xxx.cpp -o xxx.o</code>, <code>g++ xxx.o -o xxx</code></p>\n<blockquote>\n<p>待续：</p>\n<p>文件不更新时，不会重复编译？</p>\n<p>Makefile 的宏的高级用法</p>\n</blockquote>\n<h2 id=\"3-C-项目结构\"><a href=\"#3-C-项目结构\" class=\"headerlink\" title=\"3. C++项目结构\"></a>3. C++项目结构</h2><p>以Computer Vision的项目为例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── Makefile</span><br><span class=\"line\">├── build</span><br><span class=\"line\">│   ├── canny.o</span><br><span class=\"line\">│   └── cv_hw2.o</span><br><span class=\"line\">├── docs</span><br><span class=\"line\">│   ├── Ex2.docx</span><br><span class=\"line\">├── images</span><br><span class=\"line\">│   ├── bigben.jpg</span><br><span class=\"line\">│   ├── bmp</span><br><span class=\"line\">│   ├── lena.jpg</span><br><span class=\"line\">│   ├── stpietro.jpg</span><br><span class=\"line\">│   └── twows.jpg</span><br><span class=\"line\">├── output</span><br><span class=\"line\">│   ├── bigben-edge.bmp</span><br><span class=\"line\">│   ├── lena-edge.bmp</span><br><span class=\"line\">│   ├── stpietro-edge.bmp</span><br><span class=\"line\">│   └── twows-edge.bmp</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── cv_hw2</span><br><span class=\"line\">    ├── cv_hw2.cpp</span><br><span class=\"line\">    ├── include</span><br><span class=\"line\">    ├── lib</span><br><span class=\"line\">    └── test</span><br></pre></td></tr></table></figure>\n"}